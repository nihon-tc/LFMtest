package di5numeric;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
/**
 * JNA Wrapper for library <b>Di5Numeric</b>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Di5NumericLibrary extends Library {
	public static final java.lang.String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("Di5Numeric", true, di5numeric.Di5NumericLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(di5numeric.Di5NumericLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final Di5NumericLibrary INSTANCE = (Di5NumericLibrary)Native.loadLibrary(di5numeric.Di5NumericLibrary.JNA_LIBRARY_NAME, di5numeric.Di5NumericLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int D5_MAX_ROUND_NAME_LENGTH = (16);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_HALF_DOWN = (5);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_UP = (0);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_HALF_EVEN = (6);
	/// <i>native declaration : inc\numconv.h</i>
	public static final int NUMERIC_ERROR_INVALID_FORMAT = (-1);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_INFO_TRUNCATED = (2);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_INFO_NAN = (1);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_DOWN = (1);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_HALF_UP = (4);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_CEILING = (2);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_INFO_OVERFLOW = (3);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_INFO_UNDERFLOW = (4);
	/// <i>native declaration : inc\numeric.h</i>
	public static final int NUMERIC_ROUND_FLOOR = (3);
	/// <i>native declaration : inc\numconv.h</i>
	public static final int NUMERIC_ERROR_BUFFER_TOO_SHORT = (-2);
	/**
	 * Performs addition. All parameters are supposed to have the same scale.
	 * @param[in] a unscaled addend
	 * @param[in] b unscaled augend
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericAdd(const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:154</i>
	 */
	int RD5NumericAdd(di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs subtraction. All parameters are supposed to have the same scale.
	 * @param[in] a unscaled minuend
	 * @param[in] b unscaled subtrahend
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericSub(const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:167</i>
	 */
	int RD5NumericSub(di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs comparison. All parameters are supposed to have the same scale. NaN is assumed to be smaller than any Numeric that is not NaN. Two NaNs are assumed to be equal.
	 * @param[in] a unscaled value to be compared with b
	 * @param[in] b unscaled value to be compared with a
	 * @retval 1 if b is bigger than a.
	 * @retval 0 if b is equal to a.
	 * @retval -1 if b is smaller than a.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericCmp(const Numeric*, const Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:177</i>
	 */
	int RD5NumericCmp(di5numeric.Numeric a, di5numeric.Numeric b);
	/**
	 * Performs multiplication.
	 * @param[in,out] a unscaled multiplier
	 * @param[in] b 32-bit signed integer multiplicand
	 * @retval 0 Success. The result is stored in a. The input and output have the same scale.  
	 * @retval NUMERIC_INFO_NAN a is a NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. a is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. a is set NaN.
	 * @see NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericMul(Numeric*, NUMERIC_INT32)</code>
	 * <i>native declaration : inc\numeric.h:189</i>
	 */
	int RD5NumericMul(di5numeric.Numeric a, int b);
	/**
	 * Performs division.
	 * @param[in,out] a unscaled dividend
	 * @param[in] info_a->rounding_mode the rounding mode to be applied
	 * @param[in] b 32-bit signed integer divisor
	 * @retval 0 Success. The result is stored in a. The input and output have the same scale.  
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in a. The input and output have the same scale.
	 * @retval NUMERIC_INFO_NAN a is a NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. a is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. a is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericDiv(Numeric*, NumericInfo*, NUMERIC_INT32)</code>
	 * <i>native declaration : inc\numeric.h:203</i>
	 */
	int RD5NumericDiv(di5numeric.Numeric a, di5numeric.NumericInfo info_a, int b);
	/**
	 * Sets a Numeric zero.
	 * @param[out] c buffer to be set zero (The caller must prepare the buffer beforehand.)
	 * Original signature : <code>void RD5NumericSetZero(Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:209</i>
	 */
	void RD5NumericSetZero(di5numeric.Numeric c);
	/**
	 * Tests whether a Numeric is zero.
	 * @param[in] c unscaled value to be tested
	 * @retval zero if c is not zero.
	 * @retval non-zero if c is zero.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericIsZero(const Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:217</i>
	 */
	int RD5NumericIsZero(di5numeric.Numeric c);
	/**
	 * Sets a Numeric NaN.
	 * @param[out] c buffer to be set NaN (The caller must prepare the buffer beforehand.)
	 * Original signature : <code>void RD5NumericSetNan(Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:223</i>
	 */
	void RD5NumericSetNan(di5numeric.Numeric c);
	/**
	 * Tests whether a Numeric is NaN.
	 * @param[in] c unscaled value to be tested
	 * @retval zero if c is not NaN.
	 * @retval non-zero if c is NaN.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericIsNan(const Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:231</i>
	 */
	int RD5NumericIsNan(di5numeric.Numeric c);
	/**
	 * FOR DEBUGGING PURPOSE
	 * Original signature : <code>void dump(const Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:236</i>
	 */
	void dump(di5numeric.Numeric c);
	/**
	 * Performs addition.
	 * @param[in] info_a->scale scale of a
	 * @param[in] info_b->scale scale of b
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] a unscaled addend
	 * @param[in] b unscaled augend
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescalingAdd(const NumericInfo*, const NumericInfo*, const NumericInfo*, const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:260</i>
	 */
	int RD5NumericRescalingAdd(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_b, di5numeric.NumericInfo info_c, di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs subtraction.
	 * @param[in] info_a->scale scale of a
	 * @param[in] info_b->scale scale of b
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] a unscaled minuend
	 * @param[in] b unscaled subtrahend
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescalingSub(const NumericInfo*, const NumericInfo*, const NumericInfo*, const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:278</i>
	 */
	int RD5NumericRescalingSub(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_b, di5numeric.NumericInfo info_c, di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs subtraction.
	 * @param[in] info_a->scale scale of a
	 * @param[in] info_b->scale scale of b
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] a unscaled multiplier
	 * @param[in] b unscaled multiplicand
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescalingMul(const NumericInfo*, const NumericInfo*, const NumericInfo*, const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:296</i>
	 */
	int RD5NumericRescalingMul(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_b, di5numeric.NumericInfo info_c, di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs division.
	 * @param[in] info_a->scale scale of a
	 * @param[in] info_b->scale scale of b
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] a unscaled dividend
	 * @param[in] b unscaled divisor
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescalingDiv(const NumericInfo*, const NumericInfo*, const NumericInfo*, const Numeric*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:314</i>
	 */
	int RD5NumericRescalingDiv(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_b, di5numeric.NumericInfo info_c, di5numeric.Numeric a, di5numeric.Numeric b, di5numeric.Numeric c);
	/**
	 * Performs comparison. NaN is assumed to be smaller than any Numeric that is not a NaN. Two NaNs are assumed to be equal.
	 * @param[in] info_a->scale scale of a
	 * @param[in] info_b->scale scale of b
	 * @param[in] a unscaled value to be compared with b
	 * @param[in] b unscaled value to be compared with a
	 * @retval 1 if b is bigger than a.
	 * @retval 0 if b is equal to a.
	 * @retval -1 if b is smaller than a.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescalingCmp(const NumericInfo*, const NumericInfo*, const Numeric*, const Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:326</i>
	 */
	int RD5NumericRescalingCmp(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_b, di5numeric.Numeric a, di5numeric.Numeric b);
	/**
	 * Performs rounding towards positive infinity. Equlvalent to numeric_round with info_c->rounding_mode=NUMERIC_ROUND_CEILING.
	 * @param[in] info_c->scale scale of c
	 * @param[in] prec precision (number of fractional digits) of the result 
	 * @param[in,out] c unscaled value to be rounded towards positive infinity
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericCeil(const NumericInfo*, const NUMERIC_INT32, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:339</i>
	 */
	int RD5NumericCeil(di5numeric.NumericInfo info_c, int prec, di5numeric.Numeric c);
	/**
	 * Performs rounding towards negative infinity. Equlvalent to numeric_round with info_c->rounding_mode=NUMERIC_ROUND_FLOOR.
	 * @param[in] info_c->scale scale of c
	 * @param[in] prec precision (number of fractional digits) of the result
	 * @param[in,out] c unscaled value to be rounded towards negative infinity
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericFloor(const NumericInfo*, const NUMERIC_INT32, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:352</i>
	 */
	int RD5NumericFloor(di5numeric.NumericInfo info_c, int prec, di5numeric.Numeric c);
	/**
	 * Performs rounding.
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode rounding mode to be applied
	 * @param[in] prec precision (number of fractional digits) of the result
	 * @param[in,out] c unscaled value to be rounded
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN Either a or b is NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @see NUMERIC_INFO_TRUNCATED, NUMERIC_INFO_NAN, NUMERIC_INFO_OVERFLOW, NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRound(const NumericInfo*, const NUMERIC_INT32, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:367</i>
	 */
	int RD5NumericRound(di5numeric.NumericInfo info_c, int prec, di5numeric.Numeric c);
	/**
	 * Original signature : <code>NUMERIC_INT32 RD5NumericRescale(const NumericInfo*, const NumericInfo*, const Numeric*, Numeric*)</code>
	 * <i>native declaration : inc\numeric.h:369</i>
	 */
	int RD5NumericRescale(di5numeric.NumericInfo info_a, di5numeric.NumericInfo info_c, di5numeric.Numeric a, di5numeric.Numeric c);
	/**
	 * Translates the string representation of a Numeric into a Numeric.
	 * @param[in] numstr the string representation
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @param[out] endptr buffer to hold the pointer to the character following the valid string representation if endptr is not null.
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @retval NUMERIC_ERROR_INVALID_FORMAT if the string representation is not valid.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW,NUMERIC_ERROR_INVALID_FORMAT
	 * 
	 * @note
	 * 
	 * Valid string representation is described by the following grammar.
	 * 
	 * <table><tr><td>
	 * \e NumericString : \e SIGN \e UnsignedNumericString
	 *                  | \e UnsignedNumericString
	 *                  ;
	 * 
	 * \e UnsignedNumericString : \e Significand \e Exponent
	 *                          | \e Significand
	 *                          ;
	 * 
	 * \e Significand : \e IntegerPart \e POINT \e FractionPart
	 *                | \e IntegerPart \e POINT
	 *                | \e POINT \e FractionPart
	 *                | \e IntegerPart
	 *                ;
	 * 
	 * \e IntegerPart : \e Digits
	 *                ;
	 * 
	 * \e FractionPart : \e Digits
	 *                 ;
	 * 
	 * \e Exponent : \e EXPONENT_INDICATOR \e SignedInteger
	 *             ;
	 * 
	 * \e SignedInteger : \e SIGN \e Digits
	 *                  | \e Digits
	 *                  ;
	 * 
	 * \e Digits : \e DIGIT
	 *           | \e Digits \e DIGIT;
	 * 
	 * \e SIGN: + | -;
	 * 
	 * \e POINT: .;
	 * 
	 * \e EXPONENT_INDICATOR: e | E;
	 * 
	 * \e DIGIT: [0-9]{1};
	 * </td></tr></table>
	 * Original signature : <code>NUMERIC_INT32 RD5NumericStr2Num(const char*, const NumericInfo*, Numeric*, const char**)</code>
	 * <i>native declaration : inc\numconv.h:75</i>
	 * @deprecated use the safer methods {@link #RD5NumericStr2Num(java.lang.String, di5numeric.NumericInfo, di5numeric.Numeric, java.lang.String[])} and {@link #RD5NumericStr2Num(com.sun.jna.Pointer, di5numeric.NumericInfo, di5numeric.Numeric, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Mangling({"_Z17RD5NumericStr2NumPKcPK11NumericInfoP7NumericPPKc", "?RD5NumericStr2Num@@YAHPADPAUNumericInfo@@PAUNumeric@@PAPAD@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericStr2Num(Pointer numstr, di5numeric.NumericInfo info_c, di5numeric.Numeric c, PointerByReference endptr);
	/**
	 * Translates the string representation of a Numeric into a Numeric.
	 * @param[in] numstr the string representation
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @param[out] endptr buffer to hold the pointer to the character following the valid string representation if endptr is not null.
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @retval NUMERIC_ERROR_INVALID_FORMAT if the string representation is not valid.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW,NUMERIC_ERROR_INVALID_FORMAT
	 * 
	 * @note
	 * 
	 * Valid string representation is described by the following grammar.
	 * 
	 * <table><tr><td>
	 * \e NumericString : \e SIGN \e UnsignedNumericString
	 *                  | \e UnsignedNumericString
	 *                  ;
	 * 
	 * \e UnsignedNumericString : \e Significand \e Exponent
	 *                          | \e Significand
	 *                          ;
	 * 
	 * \e Significand : \e IntegerPart \e POINT \e FractionPart
	 *                | \e IntegerPart \e POINT
	 *                | \e POINT \e FractionPart
	 *                | \e IntegerPart
	 *                ;
	 * 
	 * \e IntegerPart : \e Digits
	 *                ;
	 * 
	 * \e FractionPart : \e Digits
	 *                 ;
	 * 
	 * \e Exponent : \e EXPONENT_INDICATOR \e SignedInteger
	 *             ;
	 * 
	 * \e SignedInteger : \e SIGN \e Digits
	 *                  | \e Digits
	 *                  ;
	 * 
	 * \e Digits : \e DIGIT
	 *           | \e Digits \e DIGIT;
	 * 
	 * \e SIGN: + | -;
	 * 
	 * \e POINT: .;
	 * 
	 * \e EXPONENT_INDICATOR: e | E;
	 * 
	 * \e DIGIT: [0-9]{1};
	 * </td></tr></table>
	 * Original signature : <code>NUMERIC_INT32 RD5NumericStr2Num(const char*, const NumericInfo*, Numeric*, const char**)</code>
	 * <i>native declaration : inc\numconv.h:75</i>
	 */
	@Mangling({"_Z17RD5NumericStr2NumPKcPK11NumericInfoP7NumericPPKc", "?RD5NumericStr2Num@@YAHPADPAUNumericInfo@@PAUNumeric@@PAPAD@Z"}) 
	int RD5NumericStr2Num(java.lang.String numstr, di5numeric.NumericInfo info_c, di5numeric.Numeric c, java.lang.String endptr[]);
	/**
	 * Translates the string representation of a Numeric into a Numeric.
	 * @param[in] numstr the string representation
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @param[out] endptr buffer to hold the pointer to the character following the valid string representation if endptr is not null.
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @retval NUMERIC_ERROR_INVALID_FORMAT if the string representation is not valid.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW,NUMERIC_ERROR_INVALID_FORMAT
	 * 
	 * @note
	 * 
	 * Valid string representation is described by the following grammar.
	 * 
	 * <table><tr><td>
	 * \e NumericString : \e SIGN \e UnsignedNumericString
	 *                  | \e UnsignedNumericString
	 *                  ;
	 * 
	 * \e UnsignedNumericString : \e Significand \e Exponent
	 *                          | \e Significand
	 *                          ;
	 * 
	 * \e Significand : \e IntegerPart \e POINT \e FractionPart
	 *                | \e IntegerPart \e POINT
	 *                | \e POINT \e FractionPart
	 *                | \e IntegerPart
	 *                ;
	 * 
	 * \e IntegerPart : \e Digits
	 *                ;
	 * 
	 * \e FractionPart : \e DigitsWithoutComma
	 *                 ;
	 * 
	 * \e Exponent : \e EXPONENT_INDICATOR \e SignedInteger
	 *             ;
	 * 
	 * \e SignedInteger : \e SIGN \e Digits
	 *                  | \e Digits
	 *                  ;
	 * 
	 * \e Digits : \e DigitsWithoutComma
	 *           | \e DigitsWithComma
	 *           ;
	 * 
	 * \e DigitsWithoutComma : \e LESS_THAN_FOUR_DIGITS
	 *                       | \e MORE_THAN_THREE_DIGITS
	 *                       ;
	 * 
	 * \e DigitsWithComma : \e LESS_THAN_FOUR_DIGITS \e DigitsWithLeadingComma
	 *                    ;
	 * 
	 * \e DigitsWithLeadingComma : \e THREE_DIGITS_WITH_LEADING_COMMA
	 *                           | \e DigitsWithLeadingComma \e THREE_DIGITS_WITH_LEADING_COMMA
	 *                           ;
	 * 
	 * 
	 * \e SIGN: + | -;
	 * 
	 * \e POINT: .;
	 * 
	 * \e EXPONENT_INDICATOR: e | E;
	 * 
	 * \e LESS_THAN_FOUR_DIGITS: [0-9]{1,3};
	 * 
	 * \e MORE_THAN_THREE_DIGITS: [0-9]{4,};
	 * 
	 * \e THREE_DIGITS_WITH_LEADING_COMMA: \\,[0-9]{3};
	 * </td></tr></table>
	 * Original signature : <code>NUMERIC_INT32 RD5NumericDgstr2Num(const char*, const NumericInfo*, Numeric*, const char**)</code>
	 * <i>native declaration : inc\numconv.h:153</i>
	 * @deprecated use the safer methods {@link #RD5NumericDgstr2Num(java.lang.String, di5numeric.NumericInfo, di5numeric.Numeric, java.lang.String[])} and {@link #RD5NumericDgstr2Num(com.sun.jna.Pointer, di5numeric.NumericInfo, di5numeric.Numeric, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Mangling({"_Z19RD5NumericDgstr2NumPKcPK11NumericInfoP7NumericPPKc", "?RD5NumericDgstr2Num@@YAHPADPAUNumericInfo@@PAUNumeric@@PAPAD@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericDgstr2Num(Pointer numstr, di5numeric.NumericInfo info_c, di5numeric.Numeric c, PointerByReference endptr);
	/**
	 * Translates the string representation of a Numeric into a Numeric.
	 * @param[in] numstr the string representation
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * @param[out] endptr buffer to hold the pointer to the character following the valid string representation if endptr is not null.
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * @retval NUMERIC_ERROR_INVALID_FORMAT if the string representation is not valid.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW,NUMERIC_ERROR_INVALID_FORMAT
	 * 
	 * @note
	 * 
	 * Valid string representation is described by the following grammar.
	 * 
	 * <table><tr><td>
	 * \e NumericString : \e SIGN \e UnsignedNumericString
	 *                  | \e UnsignedNumericString
	 *                  ;
	 * 
	 * \e UnsignedNumericString : \e Significand \e Exponent
	 *                          | \e Significand
	 *                          ;
	 * 
	 * \e Significand : \e IntegerPart \e POINT \e FractionPart
	 *                | \e IntegerPart \e POINT
	 *                | \e POINT \e FractionPart
	 *                | \e IntegerPart
	 *                ;
	 * 
	 * \e IntegerPart : \e Digits
	 *                ;
	 * 
	 * \e FractionPart : \e DigitsWithoutComma
	 *                 ;
	 * 
	 * \e Exponent : \e EXPONENT_INDICATOR \e SignedInteger
	 *             ;
	 * 
	 * \e SignedInteger : \e SIGN \e Digits
	 *                  | \e Digits
	 *                  ;
	 * 
	 * \e Digits : \e DigitsWithoutComma
	 *           | \e DigitsWithComma
	 *           ;
	 * 
	 * \e DigitsWithoutComma : \e LESS_THAN_FOUR_DIGITS
	 *                       | \e MORE_THAN_THREE_DIGITS
	 *                       ;
	 * 
	 * \e DigitsWithComma : \e LESS_THAN_FOUR_DIGITS \e DigitsWithLeadingComma
	 *                    ;
	 * 
	 * \e DigitsWithLeadingComma : \e THREE_DIGITS_WITH_LEADING_COMMA
	 *                           | \e DigitsWithLeadingComma \e THREE_DIGITS_WITH_LEADING_COMMA
	 *                           ;
	 * 
	 * 
	 * \e SIGN: + | -;
	 * 
	 * \e POINT: .;
	 * 
	 * \e EXPONENT_INDICATOR: e | E;
	 * 
	 * \e LESS_THAN_FOUR_DIGITS: [0-9]{1,3};
	 * 
	 * \e MORE_THAN_THREE_DIGITS: [0-9]{4,};
	 * 
	 * \e THREE_DIGITS_WITH_LEADING_COMMA: \\,[0-9]{3};
	 * </td></tr></table>
	 * Original signature : <code>NUMERIC_INT32 RD5NumericDgstr2Num(const char*, const NumericInfo*, Numeric*, const char**)</code>
	 * <i>native declaration : inc\numconv.h:153</i>
	 */
	@Mangling({"_Z19RD5NumericDgstr2NumPKcPK11NumericInfoP7NumericPPKc", "?RD5NumericDgstr2Num@@YAHPADPAUNumericInfo@@PAUNumeric@@PAPAD@Z"}) 
	int RD5NumericDgstr2Num(java.lang.String numstr, di5numeric.NumericInfo info_c, di5numeric.Numeric c, java.lang.String endptr[]);
	/**
	 * Translates a Numeric into a string representation.
	 * @param[in] c unscaled value to be translated
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] scale the exponent of the result string representation. The result string representation ends with 'E<-scale>' if scale is not zero.
	 * @param[in] prec precision (number of fractional digits without exponent) of the result
	 * @param[out] numstr buffer to hold the result.
	 * @param[in] len the length of the buffer (=numstr)
	 * 
	 * @retval 0 Success. The result is stored in numstr.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in numstr.
	 * @retval NUMERIC_INFO_NAN if c is a NaN. 'NaN' is stored in numstr.
	 * @retval NUMERIC_ERROR_BUFFER_TOO_SHORT indicating the length of buffer (=len) is too small for the buffer (=numstr) to hold the result. The contents of numstr is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_ERROR_BUFFER_TOO_SHORT
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Str(const Numeric*, const NumericInfo*, NUMERIC_INT32, NUMERIC_INT32, char*, size_t)</code>
	 * <i>native declaration : inc\numconv.h:171</i>
	 * @deprecated use the safer methods {@link #RD5NumericNum2Str(di5numeric.Numeric, di5numeric.NumericInfo, int, int, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #RD5NumericNum2Str(di5numeric.Numeric, di5numeric.NumericInfo, int, int, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z17RD5NumericNum2StrPK7NumericPK11NumericInfoiiPc6size_t", "?RD5NumericNum2Str@@YAHPAUNumeric@@PAUNumericInfo@@HHPAD6size_t@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericNum2Str(di5numeric.Numeric c, di5numeric.NumericInfo info_c, int scale, int prec, Pointer numstr, NativeSize len);
	/**
	 * Translates a Numeric into a string representation.
	 * @param[in] c unscaled value to be translated
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] scale the exponent of the result string representation. The result string representation ends with 'E<-scale>' if scale is not zero.
	 * @param[in] prec precision (number of fractional digits without exponent) of the result
	 * @param[out] numstr buffer to hold the result.
	 * @param[in] len the length of the buffer (=numstr)
	 * 
	 * @retval 0 Success. The result is stored in numstr.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in numstr.
	 * @retval NUMERIC_INFO_NAN if c is a NaN. 'NaN' is stored in numstr.
	 * @retval NUMERIC_ERROR_BUFFER_TOO_SHORT indicating the length of buffer (=len) is too small for the buffer (=numstr) to hold the result. The contents of numstr is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_ERROR_BUFFER_TOO_SHORT
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Str(const Numeric*, const NumericInfo*, NUMERIC_INT32, NUMERIC_INT32, char*, size_t)</code>
	 * <i>native declaration : inc\numconv.h:171</i>
	 */
	@Mangling({"_Z17RD5NumericNum2StrPK7NumericPK11NumericInfoiiPc6size_t", "?RD5NumericNum2Str@@YAHPAUNumeric@@PAUNumericInfo@@HHPAD6size_t@Z"}) 
	int RD5NumericNum2Str(di5numeric.Numeric c, di5numeric.NumericInfo info_c, int scale, int prec, ByteBuffer numstr, NativeSize len);
	/**
	 * Translates a Numeric into a digit-grouped (by commas) string representation.
	 * @param[in] c unscaled value to be translated
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] scale the exponent of the result string representation. The result string representation ends with 'E<-scale>' if scale is not zero.
	 * @param[in] prec precision (number of fractional digits without exponent) of the result
	 * @param[out] numstr buffer to hold the result.
	 * @param[in] len the length of the buffer (=numstr)
	 * 
	 * @retval 0 Success. The result is stored in numstr.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in numstr.
	 * @retval NUMERIC_INFO_NAN if c is a NaN. 'NaN' is stored in numstr.
	 * @retval NUMERIC_ERROR_BUFFER_TOO_SHORT indicating the length of buffer (=len) is too small for the buffer (=numstr) to hold the result. The contents of numstr is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_ERROR_BUFFER_TOO_SHORT
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Dgstr(const Numeric*, const NumericInfo*, NUMERIC_INT32, NUMERIC_INT32, char*, size_t)</code>
	 * <i>native declaration : inc\numconv.h:189</i>
	 * @deprecated use the safer methods {@link #RD5NumericNum2Dgstr(di5numeric.Numeric, di5numeric.NumericInfo, int, int, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #RD5NumericNum2Dgstr(di5numeric.Numeric, di5numeric.NumericInfo, int, int, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z19RD5NumericNum2DgstrPK7NumericPK11NumericInfoiiPc6size_t", "?RD5NumericNum2Dgstr@@YAHPAUNumeric@@PAUNumericInfo@@HHPAD6size_t@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericNum2Dgstr(di5numeric.Numeric c, di5numeric.NumericInfo info_c, int scale, int prec, Pointer numstr, NativeSize len);
	/**
	 * Translates a Numeric into a digit-grouped (by commas) string representation.
	 * @param[in] c unscaled value to be translated
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[in] scale the exponent of the result string representation. The result string representation ends with 'E<-scale>' if scale is not zero.
	 * @param[in] prec precision (number of fractional digits without exponent) of the result
	 * @param[out] numstr buffer to hold the result.
	 * @param[in] len the length of the buffer (=numstr)
	 * 
	 * @retval 0 Success. The result is stored in numstr.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in numstr.
	 * @retval NUMERIC_INFO_NAN if c is a NaN. 'NaN' is stored in numstr.
	 * @retval NUMERIC_ERROR_BUFFER_TOO_SHORT indicating the length of buffer (=len) is too small for the buffer (=numstr) to hold the result. The contents of numstr is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_ERROR_BUFFER_TOO_SHORT
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Dgstr(const Numeric*, const NumericInfo*, NUMERIC_INT32, NUMERIC_INT32, char*, size_t)</code>
	 * <i>native declaration : inc\numconv.h:189</i>
	 */
	@Mangling({"_Z19RD5NumericNum2DgstrPK7NumericPK11NumericInfoiiPc6size_t", "?RD5NumericNum2Dgstr@@YAHPAUNumeric@@PAUNumericInfo@@HHPAD6size_t@Z"}) 
	int RD5NumericNum2Dgstr(di5numeric.Numeric c, di5numeric.NumericInfo info_c, int scale, int prec, ByteBuffer numstr, NativeSize len);
	/**
	 * Converts an IEEE754 double number into a Numeric.
	 * @param[in] val IEEE754 double number to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_NAN if val is a NaN. c is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericDbl2Num(const NUMERIC_IEEE754_DOUBLE, const NumericInfo*, Numeric*)</code>
	 * <i>native declaration : inc\numconv.h:204</i>
	 */
	@Mangling({"_Z17RD5NumericDbl2NumKdPK11NumericInfoP7Numeric", "?RD5NumericDbl2Num@@YAHNPAUNumericInfo@@PAUNumeric@@@Z"}) 
	int RD5NumericDbl2Num(double val, di5numeric.NumericInfo info_c, di5numeric.Numeric c);
	/**
	 * Converts a Numeric into an IEEE754 double number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is set +inf.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is set -inf.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Dbl(const Numeric*, const NumericInfo*, NUMERIC_IEEE754_DOUBLE*)</code>
	 * <i>native declaration : inc\numconv.h:220</i>
	 * @deprecated use the safer methods {@link #RD5NumericNum2Dbl(di5numeric.Numeric, di5numeric.NumericInfo, java.nio.DoubleBuffer)} and {@link #RD5NumericNum2Dbl(di5numeric.Numeric, di5numeric.NumericInfo, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Mangling({"_Z17RD5NumericNum2DblPK7NumericPK11NumericInfoPd", "?RD5NumericNum2Dbl@@YAHPAUNumeric@@PAUNumericInfo@@PAN@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericNum2Dbl(di5numeric.Numeric c, di5numeric.NumericInfo info_c, DoubleByReference val);
	/**
	 * Converts a Numeric into an IEEE754 double number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is set +inf.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is set -inf.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Dbl(const Numeric*, const NumericInfo*, NUMERIC_IEEE754_DOUBLE*)</code>
	 * <i>native declaration : inc\numconv.h:220</i>
	 */
	@Mangling({"_Z17RD5NumericNum2DblPK7NumericPK11NumericInfoPd", "?RD5NumericNum2Dbl@@YAHPAUNumeric@@PAUNumericInfo@@PAN@Z"}) 
	int RD5NumericNum2Dbl(di5numeric.Numeric c, di5numeric.NumericInfo info_c, DoubleBuffer val);
	/**
	 * Converts a 32-bit signed integer into a Numeric.
	 * @param[in] val 32-bit signed integer to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericInt2Num(const NUMERIC_INT32, const NumericInfo*, Numeric*)</code>
	 * <i>native declaration : inc\numconv.h:234</i>
	 */
	@Mangling({"_Z17RD5NumericInt2NumKiPK11NumericInfoP7Numeric", "?RD5NumericInt2Num@@YAHHPAUNumericInfo@@PAUNumeric@@@Z"}) 
	int RD5NumericInt2Num(int val, di5numeric.NumericInfo info_c, di5numeric.Numeric c);
	/**
	 * Converts a Numeric into a 32-bit signed integer number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is undefined.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is undefined.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Int(const Numeric*, const NumericInfo*, NUMERIC_INT32*)</code>
	 * <i>native declaration : inc\numconv.h:250</i>
	 * @deprecated use the safer methods {@link #RD5NumericNum2Int(di5numeric.Numeric, di5numeric.NumericInfo, java.nio.IntBuffer)} and {@link #RD5NumericNum2Int(di5numeric.Numeric, di5numeric.NumericInfo, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z17RD5NumericNum2IntPK7NumericPK11NumericInfoPi", "?RD5NumericNum2Int@@YAHPAUNumeric@@PAUNumericInfo@@PAH@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericNum2Int(di5numeric.Numeric c, di5numeric.NumericInfo info_c, IntByReference val);
	/**
	 * Converts a Numeric into a 32-bit signed integer number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is undefined.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is undefined.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Int(const Numeric*, const NumericInfo*, NUMERIC_INT32*)</code>
	 * <i>native declaration : inc\numconv.h:250</i>
	 */
	@Mangling({"_Z17RD5NumericNum2IntPK7NumericPK11NumericInfoPi", "?RD5NumericNum2Int@@YAHPAUNumeric@@PAUNumericInfo@@PAH@Z"}) 
	int RD5NumericNum2Int(di5numeric.Numeric c, di5numeric.NumericInfo info_c, IntBuffer val);
	/**
	 * Converts a 64-bit signed integer into a Numeric.
	 * @param[in] val 64-bit signed integer to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] c buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in c.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in c.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. c is set NaN.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. c is set NaN.
	 * Original signature : <code>NUMERIC_INT32 RD5NumericLong2Num(const NUMERIC_INT64, const NumericInfo*, Numeric*)</code>
	 * <i>native declaration : inc\numconv.h:264</i>
	 */
	@Mangling({"_Z18RD5NumericLong2NumKxPK11NumericInfoP7Numeric", "?RD5NumericLong2Num@@YAH_JPAUNumericInfo@@PAUNumeric@@@Z"}) 
	int RD5NumericLong2Num(long val, di5numeric.NumericInfo info_c, di5numeric.Numeric c);
	/**
	 * Converts a Numeric into a 64-bit signed integer number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is undefined.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Long(const Numeric*, const NumericInfo*, NUMERIC_INT64*)</code>
	 * <i>native declaration : inc\numconv.h:280</i>
	 * @deprecated use the safer methods {@link #RD5NumericNum2Long(di5numeric.Numeric, di5numeric.NumericInfo, java.nio.LongBuffer)} and {@link #RD5NumericNum2Long(di5numeric.Numeric, di5numeric.NumericInfo, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Mangling({"_Z18RD5NumericNum2LongPK7NumericPK11NumericInfoPx", "?RD5NumericNum2Long@@YAHPAUNumeric@@PAUNumericInfo@@PA_J@Z"}) 
	@java.lang.Deprecated 
	int RD5NumericNum2Long(di5numeric.Numeric c, di5numeric.NumericInfo info_c, LongByReference val);
	/**
	 * Converts a Numeric into a 64-bit signed integer number.
	 * @param[in] c unscaled value to be converted
	 * @param[in] info_c->scale scale of c
	 * @param[in] info_c->rounding_mode the rounding mode to be applied
	 * @param[out] val buffer to hold the unscaled value of the result (The caller must prepare the buffer beforehand.)
	 * 
	 * @retval 0 Success. The result is stored in val.
	 * @retval NUMERIC_INFO_TRUNCATED Success with non-zero truncation. The result is stored in val.
	 * @retval NUMERIC_INFO_NAN if c is NaN. val is set NaN.
	 * @retval NUMERIC_INFO_OVERFLOW if overflow has occurred. val is undefined.
	 * @retval NUMERIC_INFO_UNDERFLOW if underflow has occurred. val is undefined.
	 * @see NUMERIC_INFO_TRUNCATED,NUMERIC_INFO_NAN,NUMERIC_INFO_OVERFLOW,NUMERIC_INFO_UNDERFLOW
	 * Original signature : <code>NUMERIC_INT32 RD5NumericNum2Long(const Numeric*, const NumericInfo*, NUMERIC_INT64*)</code>
	 * <i>native declaration : inc\numconv.h:280</i>
	 */
	@Mangling({"_Z18RD5NumericNum2LongPK7NumericPK11NumericInfoPx", "?RD5NumericNum2Long@@YAHPAUNumeric@@PAUNumericInfo@@PA_J@Z"}) 
	int RD5NumericNum2Long(di5numeric.Numeric c, di5numeric.NumericInfo info_c, LongBuffer val);
}
